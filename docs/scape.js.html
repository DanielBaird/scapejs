<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: scape.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: scape.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
// ------------------------------------------------------------------
var defaultOptions = {
    minX: 0,
    minY: 0,
    minZ: 0,

    maxX: 100,
    maxY: 100,
    maxZ: 20,

    blocksX: 10,
    blocksY: 10
};
// ------------------------------------------------------------------
// ------------------------------------------------------------------
/**
 * Represents a rendering of a landscape / moonscape / whatever
 * @param {ScapeField} field   the field being rendered
 * @param {string} dom     DOM element the scape should be rendered info.
 * @param {object} options collection of options.
 */
function Scape(field, dom, options) {
    // invoke our super constructor
    ScapeObject.call(this, options, defaultOptions);

    // save the field
    this.f = field;

    // discover DOM container
    this.element = document.getElementById(dom);
    var $elem = $(this.element);
    var containerWidth = $elem.width();
    var containerHeight = $elem.height();

    // create renderer
    var renderer = this._makeRenderer({ dom: this.element });
    // new THREE.WebGLRenderer({ antialias: true, alpha: true });
    // renderer.setClearColor( 0xffffff, 1);
    // renderer.setSize(containerWidth, containerHeight);
    // $elem.append(renderer.domElement);

    // create scene
    this.scene = new THREE.Scene();

    // add fog
    // this.scene.fog = new THREE.Fog('#ddeeff', 1, 1000);

    // create camera
    var viewAngle = 45;
    var viewAspect = containerWidth / containerHeight;
    var near = 0.1, far = 20000;

    // set up camera
    var camera = new THREE.PerspectiveCamera( viewAngle, viewAspect, near, far);
    // "up" is positive Z
    camera.up.set(0,0,1);
    // the camera defaults to position (0,0,0)
    // set the cam position to a certain offset from field-center
    camera.position.addVectors(
        this.f.center,
        new THREE.Vector3(0, -1.1 * this.f.wY, 3 * this.f.wZ)
    );

    console.log(camera.position, this.f.center, this.f.center.clone());
    camera.lookAt(this.f.center);

    // add the camera to the scene
    this.scene.add(camera);

    // var controls = new THREE.OrbitZControls(camera, renderer.domElement);
    var controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.center = this.f.center.clone();


    // create a 10x cube
    var geometry = new THREE.BoxGeometry( 5, 5, 5 );
    // var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    // var material = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );
    var material = new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FlatShading } )

    var cube00 = new THREE.Mesh( geometry, material );
    this.scene.add(cube00);

    var cube10 = new THREE.Mesh( geometry, material );
    cube10.position.copy(new THREE.Vector3(100, 0, 0));
    this.scene.add(cube10);
    var cubeh0 = new THREE.Mesh( geometry, material );
    cubeh0.position.copy(new THREE.Vector3(50, 0, 0));
    this.scene.add(cubeh0);

    var cube01 = new THREE.Mesh( geometry, material );
    cube01.position.copy(new THREE.Vector3(0, 100, 0));
    this.scene.add(cube01);

    var cube11 = new THREE.Mesh( geometry, material );
    cube11.position.copy(new THREE.Vector3(100, 100, 0));
    this.scene.add(cube11);


    var light = new THREE.PointLight(0xffffff, 1, 0);
    light.position.set(100,300,300)
    this.scene.add(light);

    // var ambientLight = new THREE.AmbientLight(0x111111);
    // this.scene.add(ambientLight);


    var axes = new THREE.AxisHelper(50);
    this.scene.add(axes);


    // f.eachColumn( function(err, c) {
    //     for (var block = 0; block &lt; c.g.length; block++) {
    //         scene.add( new THREE.Mesh(
    //             new THREE.BoxGeometry(c.dx, c.dy, c.g[block].dz),
    //             c.g[block].m
    //             // new THREE.MeshBasicMaterial({ color: 0xff0000 })
    //             // new THREE.MeshBasicMaterial( { color: 0xffff00 } )
    //         ));
    //     }
    //     // console.log(c);
    // });

    this.groundGrid();
    this.groundGrid('top');

    var lastLogAt = 0;

    render = (function unboundRender(ts) {
        if (lastLogAt + 500 &lt; ts) {
            console.log('rendering...');
            lastLogAt = ts;
        }
        requestAnimationFrame( render );
        renderer.render( this.scene, camera );
        controls.update();
    }).bind(this);

    render(0);

};
// ------------------------------------------------------------------
// inheritance
Scape.prototype = Object.create(ScapeObject.prototype);
Scape.prototype.constructor = Scape;
// ------------------------------------------------------------------
Scape.prototype.groundGrid = function(topOrBottom) {
    var gz = 0;
    var gc = 0x444444;
    if (topOrBottom == 'top') {
        gz = this.f.maxZ;
        gc = 0xccccff;
    } else {
        gz = this.f.minZ;
        gc = 0xccffcc;
    }

    var gridW = Math.max(this.f.maxX - this.f.minX, this.f.maxY - this.f.minY);

    // Grid "size" is the distance EACH WAY the grid should span.
    // So for a grid W units across, specify the size as W/2.
    var gridXY = new THREE.GridHelper(gridW/2, gridW/10);
    gridXY.setColors(gc, gc);
    gridXY.rotation.x = Math.PI/2;
    gridXY.position.set(gridW/2, gridW/2, gz);
    this.scene.add(gridXY);


    // TODO: draw the grid from minX to maxX etc at top or bottom
}
// ------------------------------------------------------------------
/**
 * Create and return a renderer.
 * @param {object} various options
 * @param {DOMElement|jQueryElem} options.dom a dom element
 * @param {integer} options.width renderer width (in pixels)
 * @param {integer} options.height renderer height (in pixels)
 */
Scape.prototype._makeRenderer = function(options) {
    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor( 0xffffff, 1);
    if (options &amp;&amp; options.dom) {
        var $dom = $(options.dom);
        renderer.setSize($dom.width(), $dom.height());
        $dom.append(renderer.domElement);
    }
    if (options &amp;&amp; options.width &amp;&amp; options.height) {
        renderer.setSize(options.width, options.height);
    }
    return renderer;
}
// ------------------------------------------------------------------
Scape.prototype.print = function() {
    console.log(
        'scape!'
    );
}
// ------------------------------------------------------------------
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Scape">Scape</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha13</a> on Mon Jan 05 2015 15:07:34 GMT+1000 (AEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
